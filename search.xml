<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>web标准与前端开发 | 青训营</title>
    <url>/2023/12/13/web%E6%A0%87%E5%87%86%E4%B8%8E%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-%E9%9D%92%E8%AE%AD%E8%90%A5/</url>
    <content><![CDATA[<h1 id="一、关于前端开发"><a href="#一、关于前端开发" class="headerlink" title="一、关于前端开发"></a>一、关于前端开发</h1><h2 id="前端的起源和架构"><a href="#前端的起源和架构" class="headerlink" title="前端的起源和架构"></a>前端的起源和架构</h2><p><strong>1989年诞生时，Web由三种技术构成：</strong></p>
<ul>
<li>HTML</li>
<li>HTTP</li>
<li>URL</li>
</ul>
<p><strong>CSS和Javascript是几年后才出现的,与HTML一起被称为前端的三驾马车。</strong></p>
<h2 id="前端的变迁"><a href="#前端的变迁" class="headerlink" title="前端的变迁"></a>前端的变迁</h2><p><strong>1. 只读时代</strong>（1989 - 2004）</p>
<p><strong>HTML&#x2F;CSS&#x2F;JavaScript</strong></p>
<ul>
<li>单向发布</li>
<li>静态只读</li>
<li>链接跳转</li>
<li>刷新页面</li>
<li>表格对齐元素</li>
<li>CGI</li>
</ul>
<p><strong>2. 体验时代</strong>（2005 - 2010）</p>
<p><strong>Ajax&#x2F;Web API&#x2F;jQuery</strong></p>
<ul>
<li>动态交互</li>
<li>社交媒体</li>
<li>用户生成内容（UGC）</li>
<li>单页应用（SPA）</li>
<li>jQuery</li>
<li>YUI</li>
</ul>
<p><strong>3. 敏捷时代</strong>（2010 - 2023）</p>
<p><strong>Fetch&#x2F;Node.js&#x2F;Webpack</strong></p>
<ul>
<li>模块化</li>
<li>组件化</li>
<li>转译（transpiling）</li>
<li>打包（bunding）</li>
<li>React.js</li>
<li>Vue.js</li>
</ul>
<h2 id="前端应用的领域"><a href="#前端应用的领域" class="headerlink" title="前端应用的领域"></a>前端应用的领域</h2><p><strong>- To Business:</strong> 针对组织机构和企业所开发的企业级应用或网站。</p>
<p><strong>- To Customer:</strong> 针对客户的门户网站、电商平台等的应用。</p>
<p><strong>- To Developer:</strong> 针对开发者，提升开发者开发、调试、运维的速度和便捷性。</p>
<p><strong>浏览器：</strong></p>
<p>Google Chrome、Firefox、Safari、Opera、Brave、 Edge <strong>（Desktop）</strong></p>
<p>Chrome、Safari <strong>（Mobile）</strong></p>
<p><strong>服务器：</strong></p>
<p>Node.js、Express.js、koa</p>
<p><strong>终端和跨端：</strong></p>
<ul>
<li>命令行&#x2F;终端：Webpack CLI、Bable CLI、Vue CLI、React CIL</li>
<li>桌面跨端：Electron、NW.js</li>
<li>移动跨端：React Native、Flutter</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h3 id="前端技术的历史可以追溯到1989年，最初由HTML、HTTP和URL构成，后来加入了CSS和JavaScript，共同构成了前端开发的基础。"><a href="#前端技术的历史可以追溯到1989年，最初由HTML、HTTP和URL构成，后来加入了CSS和JavaScript，共同构成了前端开发的基础。" class="headerlink" title="前端技术的历史可以追溯到1989年，最初由HTML、HTTP和URL构成，后来加入了CSS和JavaScript，共同构成了前端开发的基础。"></a>前端技术的历史可以追溯到1989年，最初由HTML、HTTP和URL构成，后来加入了CSS和JavaScript，共同构成了前端开发的基础。</h3><h3 id="前端经历了几个关键时代的演变："><a href="#前端经历了几个关键时代的演变：" class="headerlink" title="前端经历了几个关键时代的演变："></a>前端经历了几个关键时代的演变：</h3><ul>
<li><strong>只读时代（1989 - 2004）：</strong> 这个时期Web主要是静态只读的，以HTML、CSS和JavaScript为基础，用户进行简单的页面浏览和刷新。</li>
<li><strong>体验时代（2005 - 2010）：</strong> 引入了Ajax技术和jQuery等工具，实现了动态交互和用户生成内容，开启了社交媒体的崛起。</li>
<li><strong>敏捷时代（2010 - 2023）：</strong> 这一时期前端开发变得更工程化，引入了模块化、组件化、转译和打包等现代化概念，框架如React.js和Vue.js推动了组件化开发的兴起。</li>
</ul>
<p>前端应用领域包括面向企业的业务应用、面向客户的门户网站和电商平台，以及面向开发者的开发工具和框架。</p>
<p>前端技术也应用在不同的环境中，包括各种桌面浏览器、移动浏览器，服务器端（Node.js、Express.js、koa等），以及跨终端开发（桌面跨端和移动跨端）。</p>
<p>这些演变和应用领域的变化表明前端开发已经成为构建现代互联网应用的关键领域，从最初的简单页面到现在的复杂应用，前端技术一直在不断演进，以满足不断变化的需求。</p>
]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/12/06/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a class="link"   href="https://hexo.io/" >Hexo<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>! This is your very first post. Check <a class="link"   href="https://hexo.io/docs/" >documentation<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> or you can ask me on <a class="link"   href="https://github.com/hexojs/hexo/issues" >GitHub<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/writing.html" >Writing<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/server.html" >Server<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/generating.html" >Generating<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>前端设计模式 | 青训营</title>
    <url>/2023/12/13/%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%9D%92%E8%AE%AD%E8%90%A5/</url>
    <content><![CDATA[<h1 id="一、什么是设计模式？"><a href="#一、什么是设计模式？" class="headerlink" title="一、什么是设计模式？"></a>一、什么是设计模式？</h1><h2 id="软件设计中常见问题的解决方案模型"><a href="#软件设计中常见问题的解决方案模型" class="headerlink" title="软件设计中常见问题的解决方案模型"></a>软件设计中常见问题的解决方案模型</h2><ul>
<li>历史经验的总结</li>
<li>与特定语言无关</li>
</ul>
<h2 id="设计模式背景"><a href="#设计模式背景" class="headerlink" title="设计模式背景"></a>设计模式背景</h2><ol>
<li>模式语言：城镇、建筑、建造 (A Pattern Language: Towns, Buildings, Construction) 1977</li>
<li>设计模式：可复用面向对象软件的基础 (Design Patterns: Elements of Reusable Object-Oriented Software) 1994</li>
</ol>
<h2 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h2><p> <strong>23种设计模式</strong></p>
<ul>
<li><strong>创建型 -</strong> 如何创建一个对象</li>
<li><strong>结构型 -</strong> 如何灵活的将对象组装成较大的结构</li>
<li><strong>行为型 -</strong> 负责对象间的高效通信和职责划分</li>
</ul>
<h1 id="二、浏览器中的设计模式"><a href="#二、浏览器中的设计模式" class="headerlink" title="二、浏览器中的设计模式"></a>二、浏览器中的设计模式</h1><h2 id="单列模式"><a href="#单列模式" class="headerlink" title="单列模式"></a>单列模式</h2><p><strong>- 定义 ：</strong> 全局唯一访问对象</p>
<p><strong>- 应用场景 ：</strong> 缓存，全局状态管理等</p>
<h2 id="用单列模式实现请求缓存"><a href="#用单列模式实现请求缓存" class="headerlink" title="用单列模式实现请求缓存"></a>用单列模式实现请求缓存</h2><p><strong>静态方法(getInstance) :</strong></p>
<div class="code-container" data-rel="Typescript"><figure class="iseeu highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title function_">getInstance</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">instance</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">instance</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">instance</span> = <span class="keyword">new</span> <span class="title class_">Request</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">instance</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>如果instance存在就返回它，如果不存在就新建一个instanc并返回。</p>
<h2 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h2><p><strong>- 定义 ：</strong> 一种订阅机制，可在被订阅对象发生变化时通知订阅者。</p>
<p><strong>- 应用场景 ：</strong> 从系统架构之间的解耦，到业务中一些实现模式，像邮件订阅，上线订阅等等，应用广泛。</p>
<p><strong>如：</strong></p>
<p><strong>1. 用发布订阅模式绑定按钮</strong></p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> button = <span class="variable language_">document</span>.<span class="title function_">getElementBtId</span>(<span class="string">&quot;button&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">doSomting1</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Send message to user&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">doSomting2</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Log...&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">button.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, doSomting1);</span><br><span class="line">button.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, doSomting2);</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure></div>
<p><strong>2. 用发布订阅模式实现用户上线订阅</strong></p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">type <span class="title class_">Notify</span> = <span class="function">(<span class="params">user: User</span>) =&gt;</span> <span class="keyword">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: string;</span><br><span class="line">    <span class="attr">status</span>: <span class="string">&quot;offline&quot;</span> | <span class="string">&quot;online&quot;</span>;</span><br><span class="line">    <span class="attr">followers</span>: &#123; <span class="attr">user</span>: <span class="title class_">User</span>;<span class="attr">ontify</span>: <span class="title class_">Notify</span> &#125;[];</span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name: string</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">status</span> = <span class="string">&quot;offline&quot;</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">followers</span> = [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">subscribe</span>(<span class="params">user: User, notify: Notify</span>) &#123;</span><br><span class="line">        user.<span class="property">followers</span>.<span class="title function_">push</span>(&#123; user, notify &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">online</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">status</span> = <span class="string">&quot;online&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">followers</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">&#123; notify &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">notify</span>(<span class="variable language_">this</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h1 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h1><h2 id="1-前端设计模式基本情况"><a href="#1-前端设计模式基本情况" class="headerlink" title="1.前端设计模式基本情况"></a>1.前端设计模式基本情况</h2><p><strong>1.1 设计模式定义</strong></p>
<p><strong>1.2 设计模式背景同步</strong></p>
<p><strong>1.3 设计模式发展趋势</strong></p>
<p><strong>1.4 设计模式分类</strong></p>
<h2 id="2-浏览器中的设计模式"><a href="#2-浏览器中的设计模式" class="headerlink" title="2.浏览器中的设计模式"></a>2.浏览器中的设计模式</h2><p><strong>2.1 单例模式</strong></p>
<p><strong>2.2 发布订阅模式</strong></p>
<h2 id="设计模式并不复杂，重要的是其思维模式以及在不同编程语言及场景下的应用"><a href="#设计模式并不复杂，重要的是其思维模式以及在不同编程语言及场景下的应用" class="headerlink" title="设计模式并不复杂，重要的是其思维模式以及在不同编程语言及场景下的应用"></a><em>设计模式并不复杂，重要的是其思维模式以及在不同编程语言及场景下的应用</em></h2>]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>考研机试复习计划</title>
    <url>/2025/02/10/%E8%80%83%E7%A0%94%E6%9C%BA%E8%AF%95%E5%A4%8D%E4%B9%A0%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<h2 id="复习计划总览："><a href="#复习计划总览：" class="headerlink" title="复习计划总览："></a>复习计划总览：</h2><ul>
<li><strong>第1周</strong>：结构化程序设计</li>
<li><strong>第2周</strong>：面向对象程序设计</li>
<li><strong>第3周</strong>：数据结构</li>
<li><strong>第4周</strong>：综合复习与模拟练习</li>
</ul>
<hr>
<h3 id="第1周：结构化程序设计"><a href="#第1周：结构化程序设计" class="headerlink" title="第1周：结构化程序设计"></a><strong>第1周：结构化程序设计</strong></h3><p><strong>目标</strong>：掌握C&#x2F;C++语言的基础语法、结构化程序设计的基本结构、指针、数组、函数等核心概念。</p>
<h4 id="每日复习安排："><a href="#每日复习安排：" class="headerlink" title="每日复习安排："></a>每日复习安排：</h4><ul>
<li><p><strong>Day 1</strong>：数据类型、运算符与表达式</p>
<ul>
<li>复习基本数据类型（int, float, double, char等）及其存储形式。</li>
<li>掌握运算符（算术、关系、逻辑、位运算等）的使用。</li>
<li>理解类型别名（typedef）和类型推断（auto）。</li>
</ul>
</li>
<li><p><strong>Day 2</strong>：结构化程序的基本结构</p>
<ul>
<li>顺序结构、分支结构（if-else, switch-case）、循环结构（for, while, do-while）。</li>
<li>练习编写简单的程序，如判断素数、求阶乘等。</li>
</ul>
</li>
<li><p><strong>Day 3</strong>：指针与引用</p>
<ul>
<li>理解指针的定义与使用，掌握指针的算术运算。</li>
<li>理解指针数组、指向数组的指针、函数指针的概念。</li>
<li>掌握引用的定义与使用，理解引用与指针的区别。</li>
</ul>
</li>
<li><p><strong>Day 4</strong>：数组的定义与使用</p>
<ul>
<li>一维数组、二维数组的定义与使用。</li>
<li>字符数组与字符串处理函数（strlen, strcpy, strcmp等）。</li>
<li>练习数组相关的算法，如数组排序、查找等。</li>
</ul>
</li>
<li><p><strong>Day 5</strong>：函数</p>
<ul>
<li>函数的定义与调用，理解函数的参数传递方式（值传递、引用传递）。</li>
<li>掌握函数重载、内联函数、带默认形参值的函数。</li>
<li>理解变量的作用域与生命周期。</li>
</ul>
</li>
<li><p><strong>Day 6</strong>：结构体与共用体</p>
<ul>
<li>结构体的定义与使用，理解结构体与数组的区别。</li>
<li>共用体的定义与使用，理解共用体与结构体的区别。</li>
</ul>
</li>
<li><p><strong>Day 7</strong>：结构化程序设计方法</p>
<ul>
<li>理解“程序&#x3D;算法+数据结构”的思想。</li>
<li>练习模块划分与流程图绘制。</li>
<li>掌握穷举法、迭代法等基本算法思想。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="第2周：面向对象程序设计"><a href="#第2周：面向对象程序设计" class="headerlink" title="第2周：面向对象程序设计"></a><strong>第2周：面向对象程序设计</strong></h3><p><strong>目标</strong>：掌握C++中的面向对象编程思想，包括类、继承、多态、模板、STL等内容。</p>
<h4 id="每日复习安排：-1"><a href="#每日复习安排：-1" class="headerlink" title="每日复习安排："></a>每日复习安排：</h4><ul>
<li><p><strong>Day 1</strong>：类的定义与使用</p>
<ul>
<li>理解类与对象的关系，掌握类的定义与对象的创建。</li>
<li>掌握访问权限（public, private, protected）。</li>
<li>理解构造函数、析构函数、初始化列表的使用。</li>
</ul>
</li>
<li><p><strong>Day 2</strong>：类的继承与派生</p>
<ul>
<li>理解基类与派生类的关系，掌握继承的访问控制。</li>
<li>掌握基类与派生类的构造与析构顺序。</li>
<li>理解虚基类的概念与使用。</li>
</ul>
</li>
<li><p><strong>Day 3</strong>：多态性</p>
<ul>
<li>理解多态性的类型与实现，掌握虚函数的使用。</li>
<li>理解纯虚函数与抽象类的概念。</li>
<li>练习面向抽象编程的思想。</li>
</ul>
</li>
<li><p><strong>Day 4</strong>：模板的概念与使用</p>
<ul>
<li>掌握函数模板的定义与使用。</li>
<li>掌握类模板的定义与使用。</li>
</ul>
</li>
<li><p><strong>Day 5</strong>：STL与泛型程序设计</p>
<ul>
<li>理解STL中的顺序容器（vector, list等）、关联容器（map, set等）的使用。</li>
<li>掌握迭代器的使用，理解仿函数与函数对象的概念。</li>
<li>练习STL中的常用算法（sort, find等）。</li>
</ul>
</li>
<li><p><strong>Day 6</strong>：流（stream）的概念与使用</p>
<ul>
<li>理解I&#x2F;O流的概念，掌握文件读写操作（文本文件、二进制文件）。</li>
<li>练习使用流进行文件操作。</li>
</ul>
</li>
<li><p><strong>Day 7</strong>：异常处理</p>
<ul>
<li>理解异常处理的基本思想，掌握try-catch语句的使用。</li>
<li>理解异常处理中的构造与析构过程。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="第3周：数据结构"><a href="#第3周：数据结构" class="headerlink" title="第3周：数据结构"></a><strong>第3周：数据结构</strong></h3><p><strong>目标</strong>：掌握常见的数据结构及其基本操作，包括线性表、栈、队列、树、图、排序与查找算法。</p>
<h4 id="每日复习安排：-2"><a href="#每日复习安排：-2" class="headerlink" title="每日复习安排："></a>每日复习安排：</h4><ul>
<li><p><strong>Day 1</strong>：线性表</p>
<ul>
<li>理解线性表的顺序存储与链式存储结构。</li>
<li>练习线性表的基本操作（插入、删除、查找等）。</li>
</ul>
</li>
<li><p><strong>Day 2</strong>：栈与队列</p>
<ul>
<li>理解栈与队列的顺序存储与链式存储结构。</li>
<li>练习栈与队列的基本操作（入栈、出栈、入队、出队等）。</li>
</ul>
</li>
<li><p><strong>Day 3</strong>：树与二叉树</p>
<ul>
<li>理解二叉树的定义及其存储结构。</li>
<li>掌握二叉树的遍历（前序、中序、后序、层次遍历）。</li>
<li>理解树的存储结构，掌握树与森林的遍历。</li>
</ul>
</li>
<li><p><strong>Day 4</strong>：图</p>
<ul>
<li>理解图的存储结构（邻接矩阵、邻接表）。</li>
<li>掌握图的遍历算法（广度优先搜索、深度优先搜索）。</li>
<li>理解图的基本应用（最小生成树、最短路径、拓扑排序等）。</li>
</ul>
</li>
<li><p><strong>Day 5</strong>：排序算法</p>
<ul>
<li>掌握常见的排序算法：插入排序、冒泡排序、选择排序、快速排序等。</li>
<li>理解各排序算法的时间复杂度与空间复杂度。</li>
</ul>
</li>
<li><p><strong>Day 6</strong>：查找算法</p>
<ul>
<li>掌握顺序查找、折半查找、散列表（Hash table）的基本原理。</li>
<li>理解字符串匹配算法的基本思想。</li>
</ul>
</li>
<li><p><strong>Day 7</strong>：综合练习</p>
<ul>
<li>练习数据结构相关的编程题，如二叉树的遍历、图的遍历、排序算法等。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="第4周：综合复习与模拟练习"><a href="#第4周：综合复习与模拟练习" class="headerlink" title="第4周：综合复习与模拟练习"></a><strong>第4周：综合复习与模拟练习</strong></h3><p><strong>目标</strong>：通过模拟考试和综合练习，巩固所学知识，提升编程能力和应试技巧。</p>
<h4 id="每日复习安排：-3"><a href="#每日复习安排：-3" class="headerlink" title="每日复习安排："></a>每日复习安排：</h4><ul>
<li><p><strong>Day 1-3</strong>：综合复习</p>
<ul>
<li>复习前3周的重点内容，查漏补缺。</li>
<li>重点复习自己不熟悉的知识点，如多态性、图的应用、排序算法等。</li>
</ul>
</li>
<li><p><strong>Day 4-5</strong>：模拟考试</p>
<ul>
<li>使用在线编程平台（如LeetCode、牛客网等）进行模拟考试。</li>
<li>练习选择题、程序片段填充题、程序设计题，模拟真实考试环境。</li>
</ul>
</li>
<li><p><strong>Day 6-7</strong>：错题整理与总结</p>
<ul>
<li>整理模拟考试中的错题，分析错误原因。</li>
<li>总结常见编程题的解题思路，提升编程效率。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="复习建议："><a href="#复习建议：" class="headerlink" title="复习建议："></a>复习建议：</h3><ol>
<li><strong>多动手编程</strong>：机考注重实践能力，建议每天至少编写2-3个程序，巩固所学知识。</li>
<li><strong>注重算法与数据结构</strong>：数据结构是考试的重点，建议多练习常见的算法题，如排序、查找、树的遍历等。</li>
<li><strong>模拟考试</strong>：在最后一周进行模拟考试，熟悉考试形式，提升应试能力。</li>
<li><strong>查漏补缺</strong>：在复习过程中，及时记录自己不熟悉的知识点，重点攻克。</li>
</ol>
<p>希望这个复习计划能够帮助你顺利通过复试机考！祝你考试顺利！</p>
]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>考研复试</tag>
      </tags>
  </entry>
  <entry>
    <title>前端与HTML | 青训营</title>
    <url>/2023/12/13/%E5%89%8D%E7%AB%AF%E4%B8%8EHTML-%E9%9D%92%E8%AE%AD%E8%90%A5/</url>
    <content><![CDATA[<h1 id="写好JS的原则一：各司其责"><a href="#写好JS的原则一：各司其责" class="headerlink" title="写好JS的原则一：各司其责"></a>写好JS的原则一：各司其责</h1><h2 id="让HTML、CSS和JavaScript职能分离"><a href="#让HTML、CSS和JavaScript职能分离" class="headerlink" title="让HTML、CSS和JavaScript职能分离"></a>让HTML、CSS和JavaScript职能分离</h2><h3 id="例：深夜食堂（写一段JS、控制一个网页，使其支持深色和浅色两种模式"><a href="#例：深夜食堂（写一段JS、控制一个网页，使其支持深色和浅色两种模式" class="headerlink" title="例：深夜食堂（写一段JS、控制一个网页，使其支持深色和浅色两种模式"></a><strong>例：深夜食堂（写一段JS、控制一个网页，使其支持深色和浅色两种模式</strong></h3><p><strong>版本一：</strong></p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;modeBtn&#x27;</span>);</span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> body = <span class="variable language_">document</span>.<span class="property">body</span>;</span><br><span class="line">    <span class="keyword">if</span> (e.<span class="property">target</span>.<span class="property">innerHTML</span> === <span class="string">&#x27;🌞&#x27;</span>) &#123;</span><br><span class="line">        body.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&#x27;black&#x27;</span>;</span><br><span class="line">        body.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;white&#x27;</span>;</span><br><span class="line">        e.<span class="property">target</span>.<span class="property">innerHTML</span> = <span class="string">&#x27;🌙&#x27;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        body.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&#x27;white&#x27;</span>;</span><br><span class="line">        body.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;black&#x27;</span>;</span><br><span class="line">        e.<span class="property">target</span>.<span class="property">innerHTML</span> = <span class="string">&#x27;🌞&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>
<p><strong>版本二：</strong></p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;modeBtn&#x27;</span>);</span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> body = <span class="variable language_">document</span>.<span class="property">body</span>;</span><br><span class="line">    <span class="keyword">if</span>(body.<span class="property">className</span> !== <span class="string">&#x27;night&#x27;</span>;) &#123;</span><br><span class="line">       body.<span class="property">className</span> = <span class="string">&#x27;night&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      body.<span class="property">className</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure></div>
<p><strong>版本三：</strong></p>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;modeCheckBox&quot;</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">id</span>=<span class="string">&quot;modeBtn&quot;</span> <span class="attr">for</span>=<span class="string">&quot;modeCheckBox&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>深夜食堂<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">    ........</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></div>


<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#modeCheckBox</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#modeCheckBox</span><span class="selector-pseudo">:checked</span> + <span class="selector-class">.content</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: black;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">    <span class="attribute">transition</span>: all <span class="number">1s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p><strong>代码对比：</strong><br>版本二比版本一的代码更加整洁，版本一通过JS直接操作元素的style，而版本二是操作了classNam，且在开发中我们通常使用className来定义元素的状态。版本一中使用JS做了CSS该做的事情，没有做到HTML、CSS、JS的各司其责。版本二做到了结构表现行为分离，但是在纯样式改变的情况下只用CSS就可以实现，因此版本三是最佳的。</p>
</blockquote>
<h3 id="总结：HTML负责结构，CSS负责表现，JS负责行为，且在纯样式改变的情况下最好只用CSS控制样式，不去添加JS行为。各司其责的意思便是结构、表现、行为分离，这是在前端开发中所要遵循的一个原则。"><a href="#总结：HTML负责结构，CSS负责表现，JS负责行为，且在纯样式改变的情况下最好只用CSS控制样式，不去添加JS行为。各司其责的意思便是结构、表现、行为分离，这是在前端开发中所要遵循的一个原则。" class="headerlink" title="总结：HTML负责结构，CSS负责表现，JS负责行为，且在纯样式改变的情况下最好只用CSS控制样式，不去添加JS行为。各司其责的意思便是结构、表现、行为分离，这是在前端开发中所要遵循的一个原则。"></a>总结：HTML负责结构，CSS负责表现，JS负责行为，且在纯样式改变的情况下最好只用CSS控制样式，不去添加JS行为。各司其责的意思便是结构、表现、行为分离，这是在前端开发中所要遵循的一个原则。</h3><h1 id="写好JS的原则二：组件封装"><a href="#写好JS的原则二：组件封装" class="headerlink" title="写好JS的原则二：组件封装"></a>写好JS的原则二：组件封装</h1><h2 id="好的UI组件具备正确性、扩展性、复用性"><a href="#好的UI组件具备正确性、扩展性、复用性" class="headerlink" title="好的UI组件具备正确性、扩展性、复用性"></a>好的UI组件具备正确性、扩展性、复用性</h2><p><strong>- 组件封装</strong>：组件是指Web页面上抽出来一个个包含模板（HTML）、功能（JS）、和样式（CSS）的单元。好用的组件具备封装性、正确性、扩展性、复用性。</p>
<p><strong>- 组件设计的原则</strong>：封装性、正确性、扩展性、复用性。</p>
<p><strong>- 实现组件的步骤</strong>：结构设计、展现效果、行为设计</p>
<p><strong>- 三次重构：</strong></p>
<ul>
<li>插件化</li>
<li>模板化</li>
<li>抽象化（组件框架）</li>
</ul>
<h1 id="写好JS的原则三：过程抽象"><a href="#写好JS的原则三：过程抽象" class="headerlink" title="写好JS的原则三：过程抽象"></a>写好JS的原则三：过程抽象</h1><h2 id="应用函数式编程思想"><a href="#应用函数式编程思想" class="headerlink" title="应用函数式编程思想"></a>应用函数式编程思想</h2><ul>
<li>用来处理局部细节控制的一些方法</li>
<li>函数式编程思想的基础应用</li>
</ul>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p><strong>- Once</strong>： 为了能够让“只执行一次”的需求覆盖不同的事件处理，我们可以将这个需求剥离出来。这个过程就称为<strong>过程抽象</strong>。</p>
<p><strong>- HOF</strong>：</p>
<ul>
<li>以函数作为参数</li>
<li>以函数作为返回值</li>
<li>常用于作为函数修饰器</li>
</ul>
<p><strong>- 常用高阶函数</strong>：</p>
<ul>
<li>HOF（Once、Throttle、Debounce、Consumer&#x2F;2、Iterative）</li>
</ul>
<p><strong>- 编程范式</strong>：</p>
<ul>
<li>过程抽象&#x2F;HOF&#x2F;装饰器</li>
<li>命令式&#x2F;声明式</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="三个写JS代码的原则"><a href="#三个写JS代码的原则" class="headerlink" title="三个写JS代码的原则"></a>三个写JS代码的原则</h2><p><strong>一：各司其责，HTML、CSS。JS分别负责它们各自的任务，即结构、表现与行为。</strong></p>
<p><strong>二：组件封装，组件封装的原则即考虑其复用性、可扩展性、正确性。对组件抽象，做插件化、模板化，从而实现组件框架。</strong></p>
<p><strong>三：过程抽象，针对局部细节的实现与行为可以使用过程抽象，其是函数式编程的一个基本应用，其具有命令式和声明式两种不同的编程范式，声明式比命令式更具有可扩展性，在日常开发中我们可以更多的去考虑使用声明式来编写代码。</strong></p>
]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>如何写好Js | 青训营</title>
    <url>/2023/12/13/%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BDJs-%E9%9D%92%E8%AE%AD%E8%90%A5/</url>
    <content><![CDATA[<h1 id="第一部分：前端"><a href="#第一部分：前端" class="headerlink" title="第一部分：前端"></a>第一部分：前端</h1><h2 id="知识点一：什么是前端？"><a href="#知识点一：什么是前端？" class="headerlink" title="知识点一：什么是前端？"></a><strong>知识点一：什么是前端？</strong></h2><ul>
<li>解决GUI人机交互问题：</li>
<li>跨终端<ul>
<li>PC&#x2F;移动浏览器</li>
<li>客户端&#x2F;小程序</li>
<li>VR&#x2F;AR 等</li>
</ul>
</li>
<li>Web技术栈</li>
<li><strong>总结：前端工程师就是使用web技术栈解决多端图形用户交互界面的工程师</strong></li>
</ul>
<h2 id="知识点二：前端最基础的技术栈有哪些？"><a href="#知识点二：前端最基础的技术栈有哪些？" class="headerlink" title="知识点二：前端最基础的技术栈有哪些？"></a><strong>知识点二：前端最基础的技术栈有哪些？</strong></h2><ul>
<li>HTML（内容）</li>
<li>CSS（样式）</li>
<li>JavaScript（行为）</li>
<li>HTTP、TCP&#x2F;IP等的网路协议</li>
</ul>
<h2 id="知识点三：前端应该关注哪些方面？"><a href="#知识点三：前端应该关注哪些方面？" class="headerlink" title="知识点三：前端应该关注哪些方面？"></a><strong>知识点三：前端应该关注哪些方面？</strong></h2><ol>
<li>功能</li>
<li>美观</li>
<li>无障碍</li>
<li>安全</li>
<li>性能</li>
<li>兼容性</li>
</ol>
<h1 id="第二部分：HTML"><a href="#第二部分：HTML" class="headerlink" title="第二部分：HTML"></a>第二部分：HTML</h1><h2 id="知识点一：HTML是什么？"><a href="#知识点一：HTML是什么？" class="headerlink" title="知识点一：HTML是什么？"></a><strong>知识点一：HTML是什么？</strong></h2><ul>
<li><strong>H</strong>yper<strong>T</strong>ext（图片、标题、链接、表格）</li>
<li><strong>M</strong>arkup <strong>L</strong>anguage（标签） <code>&lt;h1&gt;标题&lt;/h1&gt;</code>、<code>&lt;img src=&quot;photo.jpg&quot;/&gt;</code>等</li>
<li>在<code>&lt;img src=&quot;photo.jpg&quot;/&gt;</code>中，<em>src</em>为<strong>属性名</strong>，<em>photo.jpg</em>为<strong>属性值</strong></li>
</ul>
<h2 id="知识点二：DOM树"><a href="#知识点二：DOM树" class="headerlink" title="知识点二：DOM树"></a><strong>知识点二：DOM树</strong></h2><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mindmap</span><br><span class="line">      document</span><br><span class="line">          html</span><br><span class="line">              head</span><br><span class="line">                  meta</span><br><span class="line">                  title &quot;Page Title&quot;</span><br><span class="line">              body</span><br><span class="line">                  h1 &quot;Heading&quot;</span><br><span class="line">                  p &quot;Page Content&quot;</span><br></pre></td></tr></table></figure></div>
<h2 id="知识点三：HTML语法"><a href="#知识点三：HTML语法" class="headerlink" title="知识点三：HTML语法"></a><strong>知识点三：HTML语法</strong></h2><ul>
<li>标签和属性不区分大小写，推荐<strong>小写</strong></li>
<li>空标签可以不闭合，比如 input、meta</li>
<li>属性值推荐使用<strong>双引号</strong>包裹</li>
<li>某些属性值可以忽略，比如 required、readonly</li>
</ul>
<p><strong>定义列表（dl）</strong>：dt（标题）、dd（具体描述）</p>
<p><strong>跳转链接（a）</strong>：<code>&lt;a href=&quot;https://www.bytedance.com/&quot; target=&quot;_blank&quot;&gt;</code><br>添加了<code>target=&quot;_blank&quot;</code>属性后表示在新的界面打开网页。</p>
<p><strong>图片（img）、音频（audio）、视频（video）</strong>：alt&#x3D;”加载失败时提示词”、controls（音频、视频控制属性）</p>
<p><strong>块级引用（blockquote）</strong>:<code>&lt;blockquote cite=&quot;http://t.cn/RfjKO0F&quot;&gt;</code>cite属性值为引用来源</p>
<p><strong>短引用（cite、q）</strong>：当引用了别人的名字或章节时使用使用<code>&lt;cite&gt;</code>，当引用具体致之前出现过的内容时用<code>&lt;q&gt;</code></p>
<p><strong>代码引用（code、pre）</strong>：在界面出现代码时引用，当出现多行代码时需要在<code>&lt;code&gt;</code>标签外套一层<code>&lt;pre&gt;</code>标签</p>
<p><strong>页面划分</strong>：常见的页面划分含有:</p>
<ul>
<li>页头<code>&lt;header&gt; </code>:可以存放logo以及导航栏<code>&lt;nav&gt;</code>等</li>
<li>主体部分<code>&lt;main&gt;</code>:一般一个页面只有一个main元素，其中可包含文字内容<code>&lt;article&gt;</code></li>
<li>侧边<code>&lt;aside&gt;</code>:可存放与主题部分无关的内容，如广告等</li>
<li>页脚<code>&lt;footer&gt;</code>:放置参考链接，备案等内容</li>
</ul>
<h2 id="知识点四：语义化是什么？"><a href="#知识点四：语义化是什么？" class="headerlink" title="知识点四：语义化是什么？"></a><strong>知识点四：语义化是什么？</strong></h2><ul>
<li>HTML中的<strong>元素</strong>、<strong>属性</strong>、以及<strong>属性值</strong>都拥有某些含义</li>
<li>开发者应该遵循<strong>语义</strong>来编写HTML<ul>
<li>有序列表用<strong>ol</strong>；无序列表用<strong>ul</strong></li>
<li><strong>lang</strong>属性表示内容所使用的语言</li>
</ul>
</li>
</ul>
<h2 id="知识点五：谁在使用我们写的HTML？"><a href="#知识点五：谁在使用我们写的HTML？" class="headerlink" title="知识点五：谁在使用我们写的HTML？"></a><strong>知识点五：谁在使用我们写的HTML？</strong></h2><ul>
<li>开发者 - 修改、维护界面</li>
<li>浏览器 - 展示界面</li>
<li>搜索引擎 - 提前关键词、排序</li>
<li>屏幕阅读器 - 给盲人读页面内容</li>
</ul>
<h2 id="知识点六：语义化的好处"><a href="#知识点六：语义化的好处" class="headerlink" title="知识点六：语义化的好处"></a><strong>知识点六：语义化的好处</strong></h2><ul>
<li>代码可读性</li>
<li>可维护性</li>
<li>搜索引擎优化</li>
<li>提升无障碍性</li>
</ul>
<h2 id="知识点七：如何做到语义化？"><a href="#知识点七：如何做到语义化？" class="headerlink" title="知识点七：如何做到语义化？"></a><strong>知识点七：如何做到语义化？</strong></h2><ul>
<li>了解每个标签和属性的含义</li>
<li>思考什么标签最适合表述这个内容</li>
<li>不使用可视化工具生成代码</li>
</ul>
<h1 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h1><p>在HTML的开发和编写中的语义化是必不可少的，本节课程向我们讲述了多个帮助我们达到语义化的标签，如<code>&lt;blockquote&gt;</code>、<code>&lt;cite&gt;</code>、<code>&lt;main&gt;</code>等的引用和划分元素标签，相较于直接使用常见标签，语义化的开发提升了我们的代码可读性和可维护性。</p>
]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>静态类型、超集、面向对象的JavaScript扩展——TS（TypeScript）</title>
    <url>/2023/12/26/%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E3%80%81%E8%B6%85%E9%9B%86%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84JavaScript%E6%89%A9%E5%B1%95%E2%80%94%E2%80%94TS%EF%BC%88TypeScript%EF%BC%89/</url>
    <content><![CDATA[<h1 id="TypeScript介绍"><a href="#TypeScript介绍" class="headerlink" title="TypeScript介绍"></a>TypeScript介绍</h1>
  <div class="note p-4 mb-4 rounded-small info">
    <p>本篇文章只对TypeScript进行了最基础的介绍，关于TS的更多文章请在“TS”标签内查看</p>

  </div>
<h2 id="什么是TS（TypeScript）-？"><a href="#什么是TS（TypeScript）-？" class="headerlink" title="什么是TS（TypeScript） ？"></a>什么是TS（TypeScript） ？</h2><p>TypeScript（简称 TS）是微软公司开发的一种基于 JavaScript （简称 JS）语言的编程语言。</p>
<p>它的目的并不是创造一种全新语言，而是增强 JavaScript 的功能，使其更适合多人合作的企业级项目。</p>
<p>TypeScript 可以看成是 JavaScript 的超集（superset），即它继承了后者的全部语法，所有 JavaScript 脚本都可以当作 TypeScript 脚本（但是可能会报错），此外它再增加了一些自己的语法。</p>
<p>TypeScript 对 JavaScript 添加的最主要部分，就是一个独立的类型系统。</p>
<p>TypeScript 被广泛用于大型项目和前端开发，它为开发者提供了更强大的工具和语法，同时与 JavaScript 保持兼容性，使得现有的 JavaScript 代码可以逐步迁移到 TypeScript 中。</p>
<blockquote>
<p>TypeScript 是 JavaScript 的一个超集，支持 ECMAScript 6 标准。</p>
<p>TypeScript 由微软开发的自由和开源的编程语言。</p>
<p>TypeScript 设计目标是开发大型应用，它可以编译成纯 JavaScript，编译出来的 JavaScript 可以运行在任何浏览器上。</p>
</blockquote>
<p>TypeScript 代码示例：</p>
<div class="code-container" data-rel="Typescript"><figure class="iseeu highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x:<span class="built_in">string</span>|<span class="built_in">number</span></span>) &#123; </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// ... </span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;number&#x27;</span>) &#123; </span><br><span class="line">        <span class="comment">// ... </span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        x; <span class="comment">// never 类型 </span></span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>TS 的发展形势非常好，至今很多 JavaScript 项目都支持 TS，比如 Vue3 和 React 前端两大框架都支持 TS。</strong></p>
<h2 id="TS相较于JS具体扩展了哪些内容？"><a href="#TS相较于JS具体扩展了哪些内容？" class="headerlink" title="TS相较于JS具体扩展了哪些内容？"></a>TS相较于JS具体扩展了哪些内容？</h2><p>TypeScript 是一种给 JavaScript 添加特性的语言扩展。增加的功能包括：</p>
<blockquote>
<ul>
<li>类型批注和编译时类型检查</li>
<li>类型推断</li>
<li>类型擦除</li>
<li>接口</li>
<li>枚举</li>
<li>Mixin</li>
<li>泛型编程</li>
<li>名字空间</li>
<li>元组</li>
<li>Await</li>
</ul>
<p>以下功能是从 ECMA 2015 反向移植而来：</p>
<ul>
<li>类</li>
<li>模块</li>
<li>lambda 函数的箭头语法</li>
<li>可选参数以及默认参数</li>
</ul>
</blockquote>
<p>我们可以直接的理解为TypeScript 是 JavaScript 的超集，扩展了 JavaScript 的语法，因此现有的 JavaScript 代码可与 TypeScript 一起工作无需任何修改，TypeScript 通过类型注解提供编译时的静态类型检查。</p>
<p><strong>TypeScript 可处理已有的 JavaScript 代码，并只对其中的 TypeScript 代码进行编译。</strong></p>
<h1 id="上手TypeScript"><a href="#上手TypeScript" class="headerlink" title="上手TypeScript"></a>上手TypeScript</h1><h2 id="tsc-编译器"><a href="#tsc-编译器" class="headerlink" title="tsc 编译器"></a>tsc 编译器</h2><p>TypeScript 官方提供的编译器叫做 tsc，可以将 TypeScript 脚本编译成 JavaScript 脚本。本机想要编译 TypeScript 代码，必须安装 tsc。</p>
<h3 id="使用npm安装"><a href="#使用npm安装" class="headerlink" title="使用npm安装"></a>使用npm安装</h3><p>安装TS需要用到npm工具，如果你的本地环境已经安装了 npm 工具，可以使用以下命令来安装。</p>
<p>使用国内镜像：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmmirror.com</span><br></pre></td></tr></table></figure></div>
<p>安装：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g typescript</span><br></pre></td></tr></table></figure></div>
<p><em>上面命令是全局安装 tsc，也可以在项目中将 tsc 安装为一个依赖模块。</em></p>
<p>安装完成后我们可以使用 tsc 命令来执行 TypeScript 的相关代码，以下是查看版本号：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ tsc -v</span><br><span class="line">Version 3.2.2</span><br></pre></td></tr></table></figure></div>
<h3 id="编译脚本"><a href="#编译脚本" class="headerlink" title="编译脚本"></a>编译脚本</h3><p>根据约定，TypeScript 脚本文件使用<code>.ts</code>后缀名，JavaScript 脚本文件使用<code>.js</code>后缀名。tsc 的作用就是把<code>.ts</code>脚本转变成<code>.js</code>脚本。</p>
<p>我们首先新建一个 app.ts 的文件，代码如下：</p>
<div class="code-container" data-rel="Typescript"><figure class="iseeu highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">message</span>:<span class="built_in">string</span> = <span class="string">&quot;Hello World&quot;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(message)</span><br></pre></td></tr></table></figure></div>

<p>执行以下命令将 TypeScript 转换为 JavaScript 代码：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">tsc app.ts</span><br></pre></td></tr></table></figure></div>
<p>这时候在当前目录下（与 app.ts 同一目录）就会生成一个 app.js 文件，代码如下：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">&quot;Hello World&quot;</span>; <span class="variable language_">console</span>.<span class="title function_">log</span>(message);</span><br></pre></td></tr></table></figure></div>
<p>使用 node 命令来执行 app.js 文件：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ node app.js </span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure></div>
<h2 id="TypeScript基础"><a href="#TypeScript基础" class="headerlink" title="TypeScript基础"></a>TypeScript基础</h2><blockquote>
<p>此部分用来介绍TypeScript 的一些最基本的语法和用法。</p>
</blockquote>
<h3 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h3><p>TypeScript 引入了一些基本类型，相比于JavaScript，这些类型在TypeScript中是静态类型的一部分，可以在编译时进行类型检查。以下是 TypeScript 的基本类型以及相较于 JavaScript 新增的一些类型：</p>
<h4 id="TypeScript新增的类型："><a href="#TypeScript新增的类型：" class="headerlink" title="TypeScript新增的类型："></a>TypeScript新增的类型：</h4><ol>
<li><p><strong>Tuple（元组）：</strong></p>
<ul>
<li>允许表示一个固定长度的数组，各元素可以有不同的类型。</li>
</ul>
<div class="code-container" data-rel="Typescript"><figure class="iseeu highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">myTuple</span>: [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">&#x27;TypeScript&#x27;</span>, <span class="number">2022</span>];</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>Enum（枚举）：</strong></p>
<ul>
<li>允许为一组数值赋予友好的名字。</li>
</ul>
<div class="code-container" data-rel="Typescript"><figure class="iseeu highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title class_">Red</span>,</span><br><span class="line">  <span class="title class_">Green</span>,</span><br><span class="line">  <span class="title class_">Blue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">myColor</span>: <span class="title class_">Color</span> = <span class="title class_">Color</span>.<span class="property">Green</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>Any（任意类型）：</strong></p>
<ul>
<li>表示一个动态类型，可以在运行时改变类型。</li>
</ul>
<div class="code-container" data-rel="Typescript"><figure class="iseeu highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">dynamicValue</span>: <span class="built_in">any</span> = <span class="string">&#x27;Hello TypeScript&#x27;</span>;</span><br><span class="line">dynamicValue = <span class="number">42</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>Void（空类型）：</strong></p>
<ul>
<li>表示没有返回值的函数的返回类型。</li>
</ul>
<div class="code-container" data-rel="Typescript"><figure class="iseeu highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">logMessage</span>(<span class="params"></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;This function has no return value&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>Never（永远不存在的值的类型）：</strong></p>
<ul>
<li>表示永远不会返回的函数的返回类型，或者抛出异常的函数。</li>
</ul>
<div class="code-container" data-rel="Typescript"><figure class="iseeu highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throwError</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h4 id="JavaScript和TypeScript共有的基本类型："><a href="#JavaScript和TypeScript共有的基本类型：" class="headerlink" title="JavaScript和TypeScript共有的基本类型："></a>JavaScript和TypeScript共有的基本类型：</h4><ol>
<li><p><strong>Boolean（布尔类型）：</strong></p>
<ul>
<li>表示逻辑值 <code>true</code> 或 <code>false</code>。</li>
</ul>
<div class="code-container" data-rel="Typescript"><figure class="iseeu highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">isDone</span>: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>Number（数字类型）：</strong></p>
<ul>
<li>表示数值，包括整数和浮点数。</li>
</ul>
<div class="code-container" data-rel="Typescript"><figure class="iseeu highlight typescript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">decimal</span>: <span class="built_in">number</span> = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">pi</span>: <span class="built_in">number</span> = <span class="number">3.14</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>String（字符串类型）：</strong></p>
<ul>
<li>表示文本数据。</li>
</ul>
<div class="code-container" data-rel="Typescript"><figure class="iseeu highlight typescript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">message</span>: <span class="built_in">string</span> = <span class="string">&#x27;Hello, TypeScript!&#x27;</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>Array（数组类型）：</strong></p>
<ul>
<li>表示一个数组，可以包含多个相同类型的元素。</li>
</ul>
<div class="code-container" data-rel="Typescript"><figure class="iseeu highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">numbers</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>Object（对象类型）：</strong></p>
<ul>
<li>表示任意JavaScript对象。</li>
</ul>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">typescriptCopy code</span><br><span class="line">let user: &#123; name: string, age: number &#125; = &#123; name: &#x27;John&#x27;, age: 30 &#125;;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="类型声明"><a href="#类型声明" class="headerlink" title="类型声明"></a>类型声明</h3><p>TypeScript 代码最明显的特征，就是为 JavaScript 变量加上了类型声明。</p>
<div class="code-container" data-rel="Typescript"><figure class="iseeu highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">foo</span>: <span class="built_in">string</span>;</span><br></pre></td></tr></table></figure></div>

<p>上面示例中，变量<code>foo</code>的后面使用冒号，声明了它的类型为<code>string</code>。</p>
<p>类型声明的写法，一律为在标识符后面添加“冒号 + 类型”。函数参数和返回值，也是这样来声明类型。</p>
<div class="code-container" data-rel="Typescript"><figure class="iseeu highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">toString</span>(<span class="params">num: <span class="built_in">number</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">String</span>(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>上面示例中，函数<code>toString()</code>的参数<code>num</code>的类型是<code>number</code>。参数列表的圆括号后面，声明了返回值的类型是<code>string</code>。更详细的介绍，参见《函数》一章。</p>
<p>注意，变量的值应该与声明的类型一致，如果不一致，TypeScript 就会报错。</p>
<div class="code-container" data-rel="Typescript"><figure class="iseeu highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">foo</span>: <span class="built_in">string</span> = <span class="number">123</span>;</span><br></pre></td></tr></table></figure></div>

<p>上面示例中，变量<code>foo</code>的类型是字符串，但是赋值为数值<code>123</code>，TypeScript 就报错了。</p>
<p>另外，TypeScript 规定，变量只有赋值后才能使用，否则就会报错。</p>
<div class="code-container" data-rel="Typescript"><figure class="iseeu highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure></div>

<p>上面示例中，变量<code>x</code>没有赋值就被读取，导致报错。而 JavaScript 允许这种行为，不会报错，没有赋值的变量会返回<code>undefined</code>。</p>
<h3 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h3><p>类型声明并不是必需的，如果没有，TypeScript 会自己推断类型。</p>
<div class="code-container" data-rel="Typescript"><figure class="iseeu highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="number">123</span>;</span><br></pre></td></tr></table></figure></div>

<p>上面示例中，变量<code>foo</code>并没有类型声明，TypeScript 就会推断它的类型。由于它被赋值为一个数值，因此 TypeScript 推断它的类型为<code>number</code>。</p>
<p>后面，如果变量<code>foo</code>更改为其他类型的值，跟推断的类型不一致，TypeScript 就会报错。</p>
<div class="code-container" data-rel="Typescript"><figure class="iseeu highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="number">123</span>;</span><br><span class="line">foo = <span class="string">&quot;hello&quot;</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure></div>

<p>上面示例中，变量<code>foo</code>的类型推断为<code>number</code>，后面赋值为字符串，TypeScript 就报错了。</p>
<p>TypeScript 也可以推断函数的返回值。</p>
<div class="code-container" data-rel="Typescript"><figure class="iseeu highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">toString</span>(<span class="params">num: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">String</span>(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>上面示例中，函数<code>toString()</code>没有声明返回值的类型，但是 TypeScript 推断返回的是字符串。正是因为 TypeScript 的类型推断，所以函数返回值的类型通常是省略不写的。</p>
<p>从这里可以看到，TypeScript 的设计思想是，类型声明是可选的，你可以加，也可以不加。即使不加类型声明，依然是有效的 TypeScript 代码，只是这时不能保证 TypeScript 会正确推断出类型。由于这个原因。所有 JavaScript 代码都是合法的 TypeScript 代码。</p>
<p>这样设计还有一个好处，将以前的 JavaScript 项目改为 TypeScript 项目时，你可以逐步地为老代码添加类型，即使有些代码没有添加，也不会无法运行。</p>
]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
</search>
